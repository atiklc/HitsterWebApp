{% extends "base.html" %}
{% block content %}

<div class="card">
  <div class="row" style="justify-content:space-between;">
    <div>
      <h2>Welcome, {{ player.name }}</h2>
      <div class="muted">
        Difficulty: <span class="pill">{{ difficulty }}</span>
        {% if status == "ended" %}
          <span class="pill" style="border-color:#4a1f1f; color:#ffb3b3;">Game ended</span>
        {% endif %}
      </div>
    </div>
  </div>

  {% if msg == "round_changed" %}
    <p class="err" style="margin-top:10px;">Round changed while you were typing. Page refreshed to keep you synced.</p>
  {% elif msg == "ended" %}
    <p class="err" style="margin-top:10px;">Game is ended. Submissions are locked.</p>
  {% endif %}

  {% if err == "enter_one" %}
    <p class="err" style="margin-top:10px;">Enter at least one field (song, artist or year).</p>
  {% endif %}
</div>

<div class="grid" style="grid-template-columns:1fr; gap:14px;" id="mainGrid">
  <!-- left -->
  <div class="card" id="roundCard">
    <h3>Round</h3>

    {% if open_round and status != "ended" %}
      <p class="muted" style="margin-top:-6px;">#{{ open_round.id }}</p>
      <p style="font-size:1.05rem; margin-top:6px;">{{ open_round.question }}</p>

      <form method="post" action="{{ url_for('submit') }}" id="guessForm">
        <input type="hidden" name="round_id" id="roundIdField" value="{{ open_round.id }}">

        <label>Song</label>
        <input name="guess_song" value="{{ my_guess.guess_song if my_guess else '' }}" autocomplete="off">

        <label>Artist</label>
        <input name="guess_artist" value="{{ my_guess.guess_artist if my_guess else '' }}" autocomplete="off">

        <label>Year</label>
        <input name="guess_year" value="{{ my_guess.guess_year if my_guess and my_guess.guess_year is not none else '' }}" inputmode="numeric">

        <div class="row" style="margin-top:10px;">
          <button class="btn" type="submit">Submit</button>
          {% if my_guess %}
            <span class="ok">Submitted (you can edit until round closes)</span>
          {% endif %}
        </div>
      </form>

    {% elif status == "ended" %}
      <p class="muted">Game ended at: {{ ended_at }}</p>
      <p class="muted">Standings will keep updating slowly for viewers.</p>

    {% else %}
      <p class="muted">No open round right now.</p>

      {% if auto_rounds and next_round_at %}
        <p class="muted">Next round scheduled at: <span id="nextAt">{{ next_round_at }}</span></p>
        <p class="muted">Countdown: <span id="countdown">...</span></p>
      {% endif %}
    {% endif %}
  </div>

  <!-- right -->
  <div class="card">
    <h3>Standings</h3>
    <div class="muted" id="standingsMeta">Live</div>

    <table style="margin-top:8px;">
      <thead>
        <tr>
          <th style="width:70px;">#</th>
          <th>Player</th>
          <th style="width:90px;">Pts</th>
          <th style="width:110px;">Δ</th>
        </tr>
      </thead>
      <tbody id="standingsBody">
        {% for s in standings %}
          <tr>
            <td>{{ s.rank }}</td>
            <td>{{ s.player }}</td>
            <td>{{ s.points }}</td>
            <td class="{% if s.delta>0 %}delta-up{% elif s.delta<0 %}delta-down{% else %}delta-same{% endif %}">
              {% if s.delta>0 %}▲ {{ s.delta }}{% elif s.delta<0 %}▼ {{ -s.delta }}{% else %}• 0{% endif %}
            </td>
          </tr>
        {% endfor %}
      </tbody>
    </table>

    {% if last_closed %}
      <hr style="border:0; border-top:1px solid var(--line); margin:14px 0;">
      <h3>Last round answers</h3>
      <p class="muted" style="margin-top:-6px;">#{{ last_closed.id }} {{ last_closed.question }}</p>

      <div class="card" style="margin-top:10px;">
        <div class="muted">Correct</div>
        <div><b>Song:</b> {{ correct.song }}</div>
        <div><b>Artist:</b> {{ correct.artist }}</div>
        <div><b>Year:</b> {{ correct.year }}</div>
      </div>

      <table style="margin-top:10px;">
        <thead>
          <tr>
            <th>Player</th>
            <th>Song</th>
            <th>Artist</th>
            <th>Year</th>
            <th style="width:70px;">Pts</th>
          </tr>
        </thead>
        <tbody>
          {% for r in last_results %}
            <tr>
              <td>{{ r.player }}</td>
              <td>{{ r.guess_song or '' }}</td>
              <td>{{ r.guess_artist or '' }}</td>
              <td>{{ r.guess_year if r.guess_year is not none else '' }}</td>
              <td>{{ r.total_points }}</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    {% endif %}
  </div>
</div>

<script>
  // Layout: force 2 columns on wider screens (no “rotate” overlay anymore)
  const mq = window.matchMedia("(min-width: 900px)");
  function applyColumns() {
    const grid = document.getElementById("mainGrid");
    if (!grid) return;
    grid.style.gridTemplateColumns = mq.matches ? "1fr 1fr" : "1fr";
  }
  mq.addEventListener("change", applyColumns);
  applyColumns();

  // Poll intervals (NOT faster than 3s)
  let STATE_MS = 4000;
  let STANDINGS_MS = 6000;

  let currentRoundId = {{ open_round.id if open_round else "null" }};
  let ended = {{ "true" if status == "ended" else "false" }};

  let stateTimer = null;
  let standingsTimer = null;

  function setText(id, txt) {
    const el = document.getElementById(id);
    if (el) el.textContent = txt;
  }

  async function refreshStandings() {
    try {
      const r = await fetch("/api/standings?ts=" + Date.now(), { cache: "no-store" });
      const data = await r.json();
      const tbody = document.getElementById("standingsBody");
      if (!tbody || !Array.isArray(data)) return;

      tbody.innerHTML = "";
      for (const row of data) {
        const delta = Number(row.delta || 0);
        const cls = delta > 0 ? "delta-up" : (delta < 0 ? "delta-down" : "delta-same");
        const sym = delta > 0 ? ("▲ " + delta) : (delta < 0 ? ("▼ " + Math.abs(delta)) : "• 0");

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.rank}</td>
          <td>${escapeHtml(row.player)}</td>
          <td>${row.points}</td>
          <td class="${cls}">${sym}</td>
        `;
        tbody.appendChild(tr);
      }
      setText("standingsMeta", ended ? "Ended (slow refresh)" : "Live");
    } catch (e) {
      // keep silent; next poll will recover
    }
  }

  async function refreshState() {
    try {
      const r = await fetch("/api/state?ts=" + Date.now(), { cache: "no-store" });
      const s = await r.json();
      if (!s || !s.ok) return;

      if (s.needs_register) {
        window.location.href = "/register";
        return;
      }

      if (s.game_status === "ended") {
        ended = true;
        // Stop state polling; keep standings slow
        if (stateTimer) { clearInterval(stateTimer); stateTimer = null; }
        if (standingsTimer) { clearInterval(standingsTimer); standingsTimer = null; }
        STANDINGS_MS = 10000;
        standingsTimer = setInterval(refreshStandings, STANDINGS_MS);
        return;
      }

      const newId = s.open_round ? s.open_round.id : null;

      // If round changes (open->none or none->open or id changes), reload once
      // This guarantees the correct round UI and prevents stale entry issues.
      if (newId !== currentRoundId) {
        window.location.href = "/game?msg=round_changed";
        return;
      }

      // Countdown (optional)
      if (!s.open_round && s.next_round_at) {
        updateCountdown(s.next_round_at);
      }

    } catch (e) {}
  }

  function updateCountdown(nextIso) {
    const dt = new Date(nextIso);
    if (isNaN(dt.getTime())) return;
    const ms = dt.getTime() - Date.now();
    const sec = Math.max(0, Math.ceil(ms / 1000));
    const el = document.getElementById("countdown");
    if (el) el.textContent = sec + "s";
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  // Start polling
  refreshStandings();
  refreshState();

  standingsTimer = setInterval(refreshStandings, STANDINGS_MS);
  if (!ended) stateTimer = setInterval(refreshState, STATE_MS);
</script>

{% endblock %}
